#include "anti_fingerprint_engine.hpp"
#include "stealth_macros.hpp"
#include "secure_memory.hpp"
#include "stealth_macros.hpp"
#include "secure_exceptions.hpp"
#include "stealth_macros.hpp"
#include "utils.hpp"
#include "stealth_macros.hpp"
#include <algorithm>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <random>
#include "stealth_macros.hpp"
#include "stealth_macros.hpp"

AntiFingerprintEngine::AntiFingerprintEngine() {
    initialize_known_signatures();
}

AntiFingerprintEngine::~AntiFingerprintEngine() = default;

void AntiFingerprintEngine::initialize_known_signatures() {
    std::lock_guard<std::mutex> lock(fingerprint_mutex_);
    
    // COMPREHENSIVE: Define ALL known library signatures that leave traces
    // This database covers every major PDF processing library and tool
    
    // Poppler signatures (extensive coverage)
    known_signatures_.push_back({
        "Poppler",
        {
            "poppler", "Poppler", "POPPLER", "libpoppler",
            "cairo", "Cairo", "CAIRO", "libcairo",
            "FreeType", "freetype", "FREETYPE", "libfreetype",
            "fontconfig", "Fontconfig", "FONTCONFIG",
            "glib", "GLib", "GLIB", "libglib",
            "pixman", "Pixman", "PIXMAN", "libpixman",
            "splash", "Splash", "SPLASH"
        },
        {
            "/Producer", "/Creator", "/ModDate", "/CreationDate", "/Title", "/Subject", "/Author"
        },
        {
            "poppler", "cairo", "GPL Ghostscript", "FreeType", "fontconfig"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'", // Poppler timestamp format
            "D:\\d{8}\\d{6}[+-]\\d{2}'\\d{2}'"
        },
        {
            "poppler-[0-9]+\\.[0-9]+\\.[0-9]+",
            "cairo [0-9]+\\.[0-9]+\\.[0-9]+",
            "FreeType [0-9]+\\.[0-9]+\\.[0-9]+",
            "poppler version [0-9]+\\.[0-9]+"
        }
    });
    
    // PDFium signatures (Google Chrome/Chromium PDF engine)
    known_signatures_.push_back({
        "PDFium",
        {
            "PDFium", "pdfium", "PDFIUM", "libpdfium",
            "Chromium", "chromium", "CHROMIUM",
            "Chrome PDF", "Chrome", "chrome",
            "Skia", "skia", "SKIA", "libskia",
            "V8", "v8", "libv8",
            "Blink", "blink", "WebKit", "webkit"
        },
        {
            "/Producer", "/Creator", "/ModDate", "/CreationDate"
        },
        {
            "PDFium", "Chromium", "Chrome PDF Viewer", "Skia"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "PDFium [0-9]+\\.[0-9]+",
            "Chromium [0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+",
            "Chrome/[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+",
            "Skia/[0-9]+\\.[0-9]+"
        }
    });
    
    // Adobe Acrobat/Reader signatures
    known_signatures_.push_back({
        "Adobe",
        {
            "Adobe", "ADOBE", "Acrobat", "ACROBAT",
            "Adobe Acrobat", "Adobe Reader", "Adobe PDF",
            "Adobe PDF Library", "Adobe Systems",
            "Distiller", "DISTILLER", "Adobe Distiller",
            "Adobe InDesign", "Adobe Illustrator", "Adobe Photoshop"
        },
        {
            "/Producer", "/Creator", "/ModDate", "/CreationDate", "/Title", "/Author"
        },
        {
            "Adobe Acrobat", "Adobe PDF Library", "Adobe Distiller"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "Adobe Acrobat [0-9]+\\.[0-9]+",
            "Adobe PDF Library [0-9]+\\.[0-9]+",
            "Adobe Distiller [0-9]+\\.[0-9]+"
        }
    });
    
    // iText signatures (comprehensive Java/C# PDF library coverage)
    known_signatures_.push_back({
        "iText",
        {
            "iText", "itext", "ITEXT", "libitext",
            "iTextSharp", "itextsharp", "ITEXTSHARP",
            "iText Software", "iText Group", "iTextPDF",
            "com.itextpdf", "com.lowagie", "Paulo Soares",
            "Bruno Lowagie", "iText LLC", "1T3XT BVBA"
        },
        {
            "/Producer", "/Creator", "/ModDate", "/CreationDate", "/Title", "/Author", "/Subject"
        },
        {
            "iText", "iTextSharp", "iText Software", "iTextPDF"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "iText[® ]?[0-9]+\\.[0-9]+\\.[0-9]+",
            "iTextSharp[™ ]?[0-9]+\\.[0-9]+\\.[0-9]+",
            "iText Software Corp\\.",
            "iText Group NV",
            "This document was generated by"
        }
    });
    
    // Apache PDFBox signatures
    known_signatures_.push_back({
        "PDFBox",
        {
            "PDFBox", "pdfbox", "PDFBOX", "Apache PDFBox",
            "org.apache.pdfbox", "apache", "Apache Software Foundation",
            "fontbox", "FontBox", "FONTBOX",
            "jempbox", "JempBox", "JEMPBOX",
            "xmpbox", "XmpBox", "XMPBOX"
        },
        {
            "/Producer", "/Creator", "/ModDate", "/CreationDate"
        },
        {
            "Apache PDFBox", "PDFBox", "Apache Software Foundation"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "Apache PDFBox version [0-9]+\\.[0-9]+\\.[0-9]+",
            "PDFBox-[0-9]+\\.[0-9]+\\.[0-9]+",
            "org\\.apache\\.pdfbox"
        }
    });
    
    // QPDF signatures (comprehensive)
    known_signatures_.push_back({
        "QPDF",
        {
            "qpdf", "QPDF", "libqpdf", "LIBQPDF",
            "Jay Berkenbilt", "qpdf library",
            "Zlib", "zlib", "ZLIB"
        },
        {
            "/Producer", "/Creator", "/ModDate"
        },
        {
            "qpdf", "QPDF library", "qpdf version"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "qpdf [0-9]+\\.[0-9]+\\.[0-9]+",
            "qpdf version [0-9]+\\.[0-9]+",
            "QPDF [0-9]+\\.[0-9]+"
        }
    });
    
    // Ghostscript signatures (comprehensive)
    known_signatures_.push_back({
        "Ghostscript",
        {
            "GPL Ghostscript", "Ghostscript", "ghostscript", "GHOSTSCRIPT",
            "AFPL Ghostscript", "GNU Ghostscript", "Artifex",
            "ps2pdf", "PS2PDF", "pdf2ps", "PDF2PS",
            "gs", "GS", "gsapi", "GSAPI",
            "PostScript", "postscript", "POSTSCRIPT"
        },
        {
            "/Producer", "/Creator", "/ModDate", "/CreationDate"
        },
        {
            "GPL Ghostscript", "Ghostscript", "AFPL Ghostscript"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "GPL Ghostscript [0-9]+\\.[0-9]+",
            "AFPL Ghostscript [0-9]+\\.[0-9]+",
            "GNU Ghostscript [0-9]+\\.[0-9]+",
            "Artifex Ghostscript [0-9]+\\.[0-9]+"
        }
    });
    
    // MuPDF signatures (comprehensive)
    known_signatures_.push_back({
        "MuPDF",
        {
            "MuPDF", "mupdf", "MUPDF", "libmupdf",
            "Artifex MuPDF", "Artifex", "ARTIFEX",
            "fitz", "Fitz", "FITZ", "libfitz",
            "mupdf-js", "mudraw", "mutool"
        },
        {
            "/Producer", "/Creator", "/ModDate"
        },
        {
            "MuPDF", "Artifex MuPDF", "MuPDF library"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "MuPDF [0-9]+\\.[0-9]+",
            "Artifex MuPDF [0-9]+\\.[0-9]+",
            "MuPDF version [0-9]+\\.[0-9]+"
        }
    });
    
    // PDFtk signatures (comprehensive)
    known_signatures_.push_back({
        "PDFtk",
        {
            "pdftk", "PDFtk", "PDFTK", "PDF Toolkit",
            "Sid Steward", "PDF Labs", "pdflabs",
            "gcj", "GCJ", "GNU Compiler"
        },
        {
            "/Producer", "/Creator", "/ModDate"
        },
        {
            "pdftk", "PDF Toolkit", "PDFtk Server"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "pdftk [0-9]+\\.[0-9]+\\.[0-9]+",
            "PDFtk [0-9]+\\.[0-9]+",
            "PDF Toolkit [0-9]+\\.[0-9]+"
        }
    });
    
    // Microsoft Office signatures
    known_signatures_.push_back({
        "Microsoft",
        {
            "Microsoft", "MICROSOFT", "Office", "OFFICE",
            "Word", "WORD", "PowerPoint", "POWERPOINT",
            "Excel", "EXCEL", "Outlook", "OUTLOOK",
            "Microsoft Print to PDF", "Microsoft Office",
            "Microsoft Corporation", "Redmond"
        },
        {
            "/Producer", "/Creator", "/Title", "/Author", "/Subject"
        },
        {
            "Microsoft", "Microsoft Office", "Microsoft Print to PDF"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "Microsoft Office [0-9]+\\.[0-9]+",
            "Microsoft Word [0-9]+\\.[0-9]+",
            "Microsoft PowerPoint [0-9]+\\.[0-9]+"
        }
    });
    
    // LibreOffice/OpenOffice signatures
    known_signatures_.push_back({
        "LibreOffice",
        {
            "LibreOffice", "LIBREOFFICE", "OpenOffice", "OPENOFFICE",
            "Apache OpenOffice", "StarOffice", "STAROFFICE",
            "Writer", "WRITER", "Calc", "CALC",
            "Impress", "IMPRESS", "Draw", "DRAW",
            "The Document Foundation", "Oracle", "Sun Microsystems"
        },
        {
            "/Producer", "/Creator", "/Title", "/Author", "/Subject"
        },
        {
            "LibreOffice", "OpenOffice", "Apache OpenOffice"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "LibreOffice [0-9]+\\.[0-9]+",
            "OpenOffice [0-9]+\\.[0-9]+",
            "Apache OpenOffice [0-9]+\\.[0-9]+"
        }
    });
    
    // LaTeX/TeX signatures
    known_signatures_.push_back({
        "LaTeX",
        {
            "LaTeX", "LATEX", "TeX", "TEX",
            "pdfTeX", "PDFTEX", "XeTeX", "XETEX",
            "LuaTeX", "LUATEX", "dvips", "DVIPS",
            "MiKTeX", "MIKTEX", "TeX Live", "TEXLIVE",
            "Donald Knuth", "Leslie Lamport"
        },
        {
            "/Producer", "/Creator", "/Title", "/Author", "/Subject"
        },
        {
            "LaTeX", "pdfTeX", "XeTeX", "LuaTeX"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "pdfTeX-[0-9]+\\.[0-9]+\\.[0-9]+",
            "XeTeX [0-9]+\\.[0-9]+",
            "LuaTeX [0-9]+\\.[0-9]+"
        }
    });
    
    // Python libraries signatures
    known_signatures_.push_back({
        "Python",
        {
            "PyPDF2", "pypdf2", "PYPDF2", "PyPDF4", "pypdf4",
            "reportlab", "ReportLab", "REPORTLAB",
            "weasyprint", "WeasyPrint", "WEASYPRINT",
            "pdfkit", "PDFKit", "PDFKIT",
            "matplotlib", "Matplotlib", "MATPLOTLIB",
            "fpdf", "FPDF", "pyfpdf"
        },
        {
            "/Producer", "/Creator", "/Title", "/Author"
        },
        {
            "PyPDF2", "ReportLab", "WeasyPrint", "matplotlib"
        },
        {
            "D:\\d{14}[+-]\\d{2}'\\d{2}'"
        },
        {
            "PyPDF2 [0-9]+\\.[0-9]+",
            "ReportLab PDF Library",
            "WeasyPrint [0-9]+\\.[0-9]+"
        }
    });

    // PROJECT-SPECIFIC LIBRARIES: Add ALL libraries used in THIS project
    // This prevents watermarks from our own dependencies
    
    // OpenSSL signatures (we use OpenSSL extensively)
    known_signatures_.push_back({
        "OpenSSL",
        {
            "OpenSSL", "openssl", "OPENSSL", "libssl", "libcrypto",
            "SSL_", "EVP_", "BIO_", "X509_", "RSA_", "AES_",
            "HMAC_", "SHA_", "MD5_", "RAND_", "BN_",
            "ECDSA_", "ECDH_", "DH_", "DSA_", "PKCS",
            "PEM_", "ASN1_", "OSSL_", "ENGINE_",
            "OpenSSL Project", "openssl.org"
        },
        {
            "/Producer", "/Creator", "/Security", "/Encryption"
        },
        {
            "OpenSSL", "libssl", "libcrypto"
        },
        {},
        {
            "OpenSSL [0-9]+\\.[0-9]+\\.[0-9]+[a-z]?",
            "OpenSSL/[0-9]+\\.[0-9]+\\.[0-9]+",
            "libssl [0-9]+\\.[0-9]+",
            "libcrypto [0-9]+\\.[0-9]+"
        }
    });
    
    // zlib signatures (used for compression)
    known_signatures_.push_back({
        "zlib",
        {
            "zlib", "ZLIB", "libz", "deflate", "inflate",
            "gzip", "GZIP", "compress", "uncompress",
            "Jean-loup Gailly", "Mark Adler", "zlib.net"
        },
        {
            "/Filter", "/DecodeParms", "/FlateDecode"
        },
        {
            "zlib", "libz"
        },
        {},
        {
            "zlib [0-9]+\\.[0-9]+\\.[0-9]+",
            "libz [0-9]+\\.[0-9]+",
            "zlib version [0-9]+\\.[0-9]+"
        }
    });
    
    // CMake signatures (build system)
    known_signatures_.push_back({
        "CMake",
        {
            "CMake", "CMAKE", "cmake", "CTest", "CPack",
            "Kitware", "cmake.org", "CMAKE_",
            "Generated by CMake", "CMake built"
        },
        {
            "/Producer", "/Creator", "/BuildSystem"
        },
        {
            "CMake", "Generated by CMake"
        },
        {},
        {
            "CMake [0-9]+\\.[0-9]+\\.[0-9]+",
            "cmake version [0-9]+\\.[0-9]+"
        }
    });
    
    // GCC/G++ signatures (compiler)
    known_signatures_.push_back({
        "GCC",
        {
            "GCC", "gcc", "G++", "g++", "GNU Compiler",
            "Free Software Foundation", "fsf.org",
            "__GNUC__", "__VERSION__", "libgcc", "libstdc++",
            "GNU C++", "GNU C Library", "glibc"
        },
        {
            "/Producer", "/Creator", "/Compiler"
        },
        {
            "GCC", "GNU Compiler", "libgcc"
        },
        {},
        {
            "gcc version [0-9]+\\.[0-9]+\\.[0-9]+",
            "GCC [0-9]+\\.[0-9]+",
            "GNU C\\+\\+ [0-9]+\\.[0-9]+"
        }
    });
    
    // Nix package manager signatures (build environment)
    known_signatures_.push_back({
        "Nix",
        {
            "Nix", "nix", "NIX", "/nix/store", "nixpkgs",
            "NixOS", "nixos.org", "nix-build", "nix-shell"
        },
        {
            "/Producer", "/Creator", "/BuildEnvironment"
        },
        {
            "Nix", "NixOS"
        },
        {},
        {
            "Nix [0-9]+\\.[0-9]+",
            "nixpkgs [0-9]+\\.[0-9]+"
        }
    });
    
    // pkg-config signatures
    known_signatures_.push_back({
        "pkg-config",
        {
            "pkg-config", "pkgconfig", "PKG_CONFIG",
            "freedesktop.org"
        },
        {
            "/Producer", "/Creator"
        },
        {
            "pkg-config"
        },
        {},
        {
            "pkg-config [0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // libmicrohttpd signatures (web server component)
    known_signatures_.push_back({
        "libmicrohttpd",
        {
            "libmicrohttpd", "microhttpd", "MHD_", "GNU libmicrohttpd",
            "Christian Grothoff"
        },
        {
            "/Producer", "/Creator", "/Server"
        },
        {
            "libmicrohttpd", "GNU libmicrohttpd"
        },
        {},
        {
            "libmicrohttpd [0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // curl signatures (HTTP client)
    known_signatures_.push_back({
        "curl",
        {
            "curl", "CURL", "libcurl", "Daniel Stenberg",
            "curl.se", "User-Agent: curl"
        },
        {
            "/Producer", "/Creator", "/HTTPClient"
        },
        {
            "curl", "libcurl"
        },
        {},
        {
            "curl [0-9]+\\.[0-9]+\\.[0-9]+",
            "libcurl/[0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // nlohmann_json signatures
    known_signatures_.push_back({
        "nlohmann_json",
        {
            "nlohmann", "json", "JSON for Modern C++",
            "Niels Lohmann", "github.com/nlohmann"
        },
        {
            "/Producer", "/Creator", "/JSON"
        },
        {
            "nlohmann", "JSON for Modern C++"
        },
        {},
        {
            "nlohmann/json [0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // Google Test signatures
    known_signatures_.push_back({
        "GoogleTest",
        {
            "gtest", "GoogleTest", "Google Test", "googletest",
            "Google Inc", "testing::", "TEST(", "EXPECT_", "ASSERT_"
        },
        {
            "/Producer", "/Creator", "/TestFramework"
        },
        {
            "GoogleTest", "Google Test"
        },
        {},
        {
            "GoogleTest [0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // Standard C++ Library signatures
    known_signatures_.push_back({
        "libstdc++",
        {
            "libstdc++", "GNU libstdc++", "stdlibc++",
            "std::", "__GLIBCXX__", "libsupc++",
            "GNU Standard C++ Library"
        },
        {
            "/Producer", "/Creator", "/Library"
        },
        {
            "libstdc++", "GNU libstdc++"
        },
        {},
        {
            "libstdc\\+\\+ [0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // POSIX/Linux system libraries
    known_signatures_.push_back({
        "glibc",
        {
            "glibc", "GNU C Library", "libc", "GLIBC",
            "__GLIBC__", "GNU/Linux", "linux-gnu"
        },
        {
            "/Producer", "/Creator", "/SystemLibrary"
        },
        {
            "glibc", "GNU C Library"
        },
        {},
        {
            "glibc [0-9]+\\.[0-9]+",
            "GNU C Library [0-9]+\\.[0-9]+"
        }
    });
    
    // pthread library
    known_signatures_.push_back({
        "pthread",
        {
            "pthread", "libpthread", "POSIX Threads",
            "pthreads", "PTHREAD"
        },
        {
            "/Producer", "/Creator", "/Threading"
        },
        {
            "pthread", "POSIX Threads"
        },
        {},
        {
            "pthread [0-9]+\\.[0-9]+"
        }
    });
    
    // libm (math library)
    known_signatures_.push_back({
        "libm",
        {
            "libm", "math.h", "LIBM", "GNU Math Library"
        },
        {
            "/Producer", "/Creator"
        },
        {
            "libm", "GNU Math Library"
        },
        {},
        {
            "libm [0-9]+\\.[0-9]+"
        }
    });
    
    // libdl (dynamic loading)
    known_signatures_.push_back({
        "libdl",
        {
            "libdl", "dlopen", "dlsym", "LIBDL",
            "Dynamic Loading Library"
        },
        {
            "/Producer", "/Creator"
        },
        {
            "libdl"
        },
        {},
        {
            "libdl [0-9]+\\.[0-9]+"
        }
    });
    
    // Replit environment signatures
    known_signatures_.push_back({
        "Replit",
        {
            "Replit", "replit", "REPLIT", "repl.it",
            "Replit Deployments", "replit.com",
            "REPL_ID", "REPL_SLUG", "REPLIT_CLUSTER"
        },
        {
            "/Producer", "/Creator", "/Environment"
        },
        {
            "Replit", "Replit Deployments"
        },
        {},
        {
            "Replit [0-9]+\\.[0-9]+"
        }
    });
    
    // Node.js signatures (from package.json)
    known_signatures_.push_back({
        "Node.js",
        {
            "Node.js", "nodejs", "NODE", "npm", "NPM",
            "V8 JavaScript Engine", "libuv", "http-parser",
            "node_modules", "package.json", "package-lock.json"
        },
        {
            "/Producer", "/Creator", "/Runtime"
        },
        {
            "Node.js", "npm"
        },
        {},
        {
            "Node\\.js v[0-9]+\\.[0-9]+\\.[0-9]+",
            "npm [0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // Python signatures (Python HTTP server)
    known_signatures_.push_back({
        "Python",
        {
            "Python", "python", "PYTHON", "CPython",
            "Python Software Foundation", "python.org",
            "SimpleHTTPServer", "http.server"
        },
        {
            "/Producer", "/Creator", "/Server"
        },
        {
            "Python", "CPython"
        },
        {},
        {
            "Python [0-9]+\\.[0-9]+\\.[0-9]+",
            "CPython [0-9]+\\.[0-9]+"
        }
    });
    
    // Docker signatures (containerization)
    known_signatures_.push_back({
        "Docker",
        {
            "Docker", "docker", "DOCKER", "dockerfile",
            "docker-compose", "containerd", "runc"
        },
        {
            "/Producer", "/Creator", "/Container"
        },
        {
            "Docker"
        },
        {},
        {
            "Docker [0-9]+\\.[0-9]+\\.[0-9]+"
        }
    });
    
    // Bash/Shell signatures
    known_signatures_.push_back({
        "Bash",
        {
            "bash", "Bash", "BASH", "GNU bash",
            "shell", "sh", "/bin/bash", "/bin/sh"
        },
        {
            "/Producer", "/Creator", "/Shell"
        },
        {
            "bash", "GNU bash"
        },
        {},
        {
            "bash [0-9]+\\.[0-9]+\\.[0-9]+",
            "GNU bash, version [0-9]+\\.[0-9]+"
        }
    });

    // COMPREHENSIVE forbidden metadata keys - all possible tool fingerprints
    forbidden_metadata_keys_ = {
        "/ModDate", "/CreationDate", "/Producer", "/Creator",
        "/Title", "/Subject", "/Author", "/Keywords",
        "/Trapped", "/PTEX.Fullbanner", "/PTEX.InfoDict",
        "/SourceModified", "/Company", "/Manager", "/Category",
        "/Comments", "/HyperlinkBase", "/LinksUpToDate",
        "/ScaleCrop", "/SharedDoc", "/Application", "/AppVersion",
        "/DocSecurity", "/Lines", "/Paragraphs", "/Characters",
        "/CharactersWithSpaces", "/DigSig", "/Template",
        "/TotalTime", "/Pages", "/Words", "/Bytes", "/Notes",
        "/Hidden", "/MMClips", "/Slides", "/PresentationFormat",
        "/SharedDocuments", "/Version", "/Build", "/OS",
        "/User", "/Computer", "/Machine", "/Domain", "/Network",
        "/Printer", "/Print", "/PrintDate", "/LastPrint",
        "/Revision", "/EditTime", "/LastSave", "/Created",
        "/Modified", "/Accessed", "/Printed", "/Security",
        "/Password", "/Encryption", "/Permissions", "/Rights",
        "/Owner", "/Group", "/ACL", "/Attributes", "/Properties",
        "/Metadata", "/XMP", "/EXIF", "/IPTC", "/Dublin Core",
        "/PDF/A", "/PDF/X", "/PDF/E", "/PDF/UA", "/PDF/VT"
    };

    // COMPREHENSIVE watermark and trace patterns
    watermark_patterns_ = {
        // Generic creation watermarks
        std::regex("Created with.*", std::regex_constants::icase),
        std::regex("Generated by.*", std::regex_constants::icase),
        std::regex("Produced by.*", std::regex_constants::icase),
        std::regex("Made with.*", std::regex_constants::icase),
        std::regex("Built with.*", std::regex_constants::icase),
        std::regex("Converted by.*", std::regex_constants::icase),
        std::regex("Processed by.*", std::regex_constants::icase),
        std::regex("Rendered by.*", std::regex_constants::icase),
        std::regex("Exported by.*", std::regex_constants::icase),
        std::regex("This document was created.*", std::regex_constants::icase),
        std::regex("This PDF was.*", std::regex_constants::icase),
        
        // License and trial watermarks
        std::regex("Watermark.*", std::regex_constants::icase),
        std::regex("Trial version.*", std::regex_constants::icase),
        std::regex("Demo version.*", std::regex_constants::icase),
        std::regex("Evaluation copy.*", std::regex_constants::icase),
        std::regex("Unregistered.*", std::regex_constants::icase),
        std::regex("Licensed to.*", std::regex_constants::icase),
        std::regex("Copyright.*", std::regex_constants::icase),
        std::regex("\\(c\\).*[0-9]{4}.*", std::regex_constants::icase),
        std::regex("©.*[0-9]{4}.*", std::regex_constants::icase),
        
        // URL and domain patterns
        std::regex("www\\.[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}", std::regex_constants::icase),
        std::regex("https?://[a-zA-Z0-9.-]+", std::regex_constants::icase),
        std::regex("[a-zA-Z0-9.-]+\\.(com|org|net|edu|gov)", std::regex_constants::icase),
        
        // Version and build information
        std::regex("Version [0-9]+\\.[0-9]+", std::regex_constants::icase),
        std::regex("Build [0-9]+", std::regex_constants::icase),
        std::regex("Release [0-9]+\\.[0-9]+", std::regex_constants::icase),
        std::regex("v[0-9]+\\.[0-9]+", std::regex_constants::icase),
        
        // Timestamp patterns that indicate processing
        std::regex("[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}", std::regex_constants::icase),
        std::regex("[0-9]{8}_[0-9]{6}", std::regex_constants::icase),
        
        // System information leaks
        std::regex("Windows [0-9]+", std::regex_constants::icase),
        std::regex("macOS [0-9]+", std::regex_constants::icase),
        std::regex("Linux [0-9]+", std::regex_constants::icase),
        std::regex("Ubuntu [0-9]+", std::regex_constants::icase),
        std::regex("User: [a-zA-Z0-9]+", std::regex_constants::icase),
        std::regex("Computer: [a-zA-Z0-9]+", std::regex_constants::icase),
        
        // Development environment traces
        std::regex("DEBUG", std::regex_constants::icase),
        std::regex("TEST", std::regex_constants::icase),
        std::regex("DEV", std::regex_constants::icase),
        std::regex("localhost", std::regex_constants::icase),
        std::regex("127\\.0\\.0\\.1", std::regex_constants::icase),
        
        // Cloud service watermarks
        std::regex("AWS", std::regex_constants::icase),
        std::regex("Azure", std::regex_constants::icase),
        std::regex("Google Cloud", std::regex_constants::icase),
        std::regex("Heroku", std::regex_constants::icase),
        std::regex("Docker", std::regex_constants::icase),
        std::regex("Kubernetes", std::regex_constants::icase)
    };
}

void AntiFingerprintEngine::set_source_pdf(const std::vector<uint8_t>& source_pdf) {
    std::lock_guard<std::mutex> lock(fingerprint_mutex_);
    load_source_fingerprints(source_pdf);
}

void AntiFingerprintEngine::load_source_fingerprints(const std::vector<uint8_t>& source_pdf) {
    // Extract authentic metadata from source PDF
    source_metadata_ = AntiFingerprintUtils::extract_authentic_metadata(source_pdf);
    
    // Store authentic values for cloning
    auto it = source_metadata_.find("CreationDate");
    if (it != source_metadata_.end()) {
        source_creation_date_ = it->second;
    }
    
    it = source_metadata_.find("ModDate");
    if (it != source_metadata_.end()) {
        source_modification_date_ = it->second;
    }
    
    it = source_metadata_.find("Producer");
    if (it != source_metadata_.end()) {
        source_producer_ = it->second;
    }
    
    it = source_metadata_.find("Creator");
    if (it != source_metadata_.end()) {
        source_creator_ = it->second;
    }
}

std::vector<uint8_t> AntiFingerprintEngine::clean_all_traces(const std::vector<uint8_t>& processed_pdf) {
    std::vector<uint8_t> cleaned_data = processed_pdf;
    
    // Apply all cleaning methods in sequence
    cleaned_data = remove_library_watermarks(cleaned_data);
    cleaned_data = replace_default_values(cleaned_data);
    cleaned_data = neutralize_timestamps(cleaned_data);
    cleaned_data = remove_tool_signatures(cleaned_data);
    cleaned_data = clean_metadata_traces(cleaned_data);
    cleaned_data = remove_compression_artifacts(cleaned_data);
    cleaned_data = sanitize_object_references(cleaned_data);
    
    // Library-specific cleaning
    cleaned_data = remove_poppler_traces(cleaned_data);
    cleaned_data = remove_pdfium_traces(cleaned_data);
    cleaned_data = remove_itext_traces(cleaned_data);
    cleaned_data = remove_pdftk_traces(cleaned_data);
    cleaned_data = remove_ghostscript_traces(cleaned_data);
    cleaned_data = remove_mupdf_traces(cleaned_data);
    cleaned_data = remove_cairo_traces(cleaned_data);
    cleaned_data = remove_qpdf_traces(cleaned_data);
    
    // Final metadata replacement with source values
    cleaned_data = replace_creation_metadata(cleaned_data);
    cleaned_data = clone_authentic_timestamps(cleaned_data);
    cleaned_data = replace_producer_info(cleaned_data);
    
    return cleaned_data;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_library_watermarks(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    for (const auto& signature : known_signatures_) {
        for (const auto& pattern : signature.signature_patterns) {
            // Remove library name patterns
            result = AntiFingerprintUtils::remove_pattern(result, pattern);
        }
    }
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::replace_default_values(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    // STRICT SOURCE-ONLY POLICY: Remove ALL tool signatures and watermarks
    // Leave fields BLANK if no source data exists
    
    // Remove ALL processing tool signatures (no replacements, just removal)
    result = AntiFingerprintUtils::remove_pattern(result, "GPL Ghostscript");
    result = AntiFingerprintUtils::remove_pattern(result, "PDFium");
    result = AntiFingerprintUtils::remove_pattern(result, "iText");
    result = AntiFingerprintUtils::remove_pattern(result, "poppler");
    result = AntiFingerprintUtils::remove_pattern(result, "qpdf");
    result = AntiFingerprintUtils::remove_pattern(result, "Adobe");
    result = AntiFingerprintUtils::remove_pattern(result, "Microsoft");
    result = AntiFingerprintUtils::remove_pattern(result, "LibreOffice");
    result = AntiFingerprintUtils::remove_pattern(result, "LaTeX");
    result = AntiFingerprintUtils::remove_pattern(result, "PyPDF2");
    result = AntiFingerprintUtils::remove_pattern(result, "ReportLab");
    result = AntiFingerprintUtils::remove_pattern(result, "OpenSSL");
    result = AntiFingerprintUtils::remove_pattern(result, "zlib");
    result = AntiFingerprintUtils::remove_pattern(result, "CMake");
    result = AntiFingerprintUtils::remove_pattern(result, "GCC");
    result = AntiFingerprintUtils::remove_pattern(result, "Nix");
    result = AntiFingerprintUtils::remove_pattern(result, "Replit");
    result = AntiFingerprintUtils::remove_pattern(result, "Node.js");
    result = AntiFingerprintUtils::remove_pattern(result, "Python");
    result = AntiFingerprintUtils::remove_pattern(result, "Docker");
    result = AntiFingerprintUtils::remove_pattern(result, "bash");
    
    // If source has authentic producer data, use it (but this is rare)
    if (!source_producer_.empty()) {
        // Only add source producer if it existed in original
        std::string data_str(result.begin(), result.end());
        if (data_str.find("/Producer") != std::string::npos) {
            // Replace empty producer field with source value
            std::regex empty_producer(R"(/Producer\s*\(\s*\))");
            data_str = std::regex_replace(data_str, empty_producer, "/Producer (" + source_producer_ + ")");
            result.assign(data_str.begin(), data_str.end());
        }
    }
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::neutralize_timestamps(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    std::string data_str(result.begin(), result.end());
    
    // EXACT SOURCE FIDELITY: Use timestamps exactly as they appear in source file
    
    // Handle ModDate field - ALWAYS blank unless authentic source exists
    std::regex moddate_pattern(R"(/ModDate\s*\([^)]*\))");
    if (!source_modification_date_.empty() && source_modification_date_ != "auto" && 
        source_modification_date_ != "current" && source_modification_date_ != "now") {
        // ONLY use authentic source timestamp from original document
        std::string replacement = "/ModDate (" + source_modification_date_ + ")";
        data_str = std::regex_replace(data_str, moddate_pattern, replacement);
    } else {
        // NO authentic source ModDate = ALWAYS blank (never show processing time)
        data_str = std::regex_replace(data_str, moddate_pattern, "/ModDate ()");
    }
    
    // Handle CreationDate field - exact source replication
    std::regex creationdate_pattern(R"(/CreationDate\s*\([^)]*\))");
    if (!source_creation_date_.empty()) {
        // Use EXACT source timestamp (whatever format it was in source)
        std::string replacement = "/CreationDate (" + source_creation_date_ + ")";
        data_str = std::regex_replace(data_str, creationdate_pattern, replacement);
    } else {
        // Source had blank/empty CreationDate - keep it blank
        data_str = std::regex_replace(data_str, creationdate_pattern, "/CreationDate ()");
    }
    
    // For any other timestamp fields that might exist, check source metadata
    std::regex other_timestamp_patterns[] = {
        std::regex(R"(/ProcessingTime\s*\([^)]*\))"),
        std::regex(R"(/BuildTime\s*\([^)]*\))"),
        std::regex(R"(/LastModified\s*\([^)]*\))"),
        std::regex(R"(/Generated\s*\([^)]*\))"),
        std::regex(R"(/Created\s*\([^)]*\))"),
        std::regex(R"(/Processed\s*\([^)]*\))")
    };
    
    std::string field_names[] = {
        "ProcessingTime", "BuildTime", "LastModified", 
        "Generated", "Created", "Processed"
    };
    
    for (size_t i = 0; i < sizeof(other_timestamp_patterns)/sizeof(other_timestamp_patterns[0]); ++i) {
        const auto& pattern = other_timestamp_patterns[i];
        const std::string& field_name = field_names[i];
        
        // Check if this field existed in source
        auto source_it = source_metadata_.find(field_name);
        if (source_it != source_metadata_.end()) {
            if (!source_it->second.empty()) {
                // Use exact source value
                std::string replacement = "/" + field_name + " (" + source_it->second + ")";
                data_str = std::regex_replace(data_str, pattern, replacement);
            } else {
                // Source had this field but it was blank
                std::string replacement = "/" + field_name + " ()";
                data_str = std::regex_replace(data_str, pattern, replacement);
            }
        } else {
            // Field didn't exist in source - make it blank
            std::string replacement = "/" + field_name + " ()";
            data_str = std::regex_replace(data_str, pattern, replacement);
        }
    }
    
    // Only remove auto-generated timestamps from stream content that weren't in source
    // (Keep timestamps that existed in source metadata fields intact)
    std::regex stream_generated_timestamps[] = {
        // Remove only processing timestamps not in metadata fields
        std::regex(R"(Processing timestamp: [0-9T:+-]+)", std::regex_constants::icase),
        std::regex(R"(Build time: [0-9T:+-]+)", std::regex_constants::icase),
        std::regex(R"(Generated at: [0-9T:+-]+)", std::regex_constants::icase)
    };
    
    for (const auto& pattern : stream_generated_timestamps) {
        data_str = std::regex_replace(data_str, pattern, "");
    }
    
    result.assign(data_str.begin(), data_str.end());
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_tool_signatures(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    // Remove specific tool signatures
    for (const auto& signature : known_signatures_) {
        for (const auto& version_pattern : signature.version_patterns) {
            std::regex pattern(version_pattern, std::regex_constants::icase);
            std::string data_str(result.begin(), result.end());
            
            if (!source_producer_.empty()) {
                data_str = std::regex_replace(data_str, pattern, source_producer_);
            } else {
                data_str = std::regex_replace(data_str, pattern, "");
            }
            
            result.assign(data_str.begin(), data_str.end());
        }
    }
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::clean_metadata_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    std::string data_str(result.begin(), result.end());
    
    // STRICT POLICY: Keep field structure intact, only clean VALUES - no deletion of fields
    
    // Clean VALUES in forbidden metadata fields (keep field structure)
    for (const auto& key : forbidden_metadata_keys_) {
        // Check if this metadata exists in source
        auto source_it = source_metadata_.find(key.substr(1)); // Remove leading '/'
        if (source_it != source_metadata_.end() && !source_it->second.empty() && 
            source_it->second != "unknown" && source_it->second != "blank" && source_it->second != "default") {
            // Replace with authentic source value ONLY
            std::regex key_pattern(key + R"(\s*\([^)]*\))");
            std::string replacement = key + " (" + source_it->second + ")";
            data_str = std::regex_replace(data_str, key_pattern, replacement);
        } else {
            // Keep field structure but make value blank - NO UNWRAPPING
            std::regex key_pattern(key + R"(\s*\([^)]*\))");
            std::string replacement = key + " ()";
            data_str = std::regex_replace(data_str, key_pattern, replacement);
        }
    }
    
    // Clean tool signatures from metadata values (keep fields intact)
    std::regex tool_signature_cleaners[] = {
        std::regex(R"(/Producer\s*\([^)]*(?:GPL Ghostscript|PDFtk|qpdf|Adobe|Microsoft|LibreOffice|OpenSSL|zlib|CMake|GCC)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(/Creator\s*\([^)]*(?:GPL Ghostscript|PDFtk|qpdf|Adobe|Microsoft|LibreOffice|OpenSSL|zlib|CMake|GCC)[^)]*\))", std::regex_constants::icase)
    };
    
    for (const auto& pattern : tool_signature_cleaners) {
        // Extract field name and replace with blank value or source value
        std::sregex_iterator iter(data_str.begin(), data_str.end(), pattern);
        std::sregex_iterator end;
        
        for (; iter != end; ++iter) {
            const std::smatch& match = *iter;
            std::string field_match = match.str();
            
            // Extract field name
            size_t slash_pos = field_match.find('/');
            size_t space_pos = field_match.find(' ', slash_pos);
            if (slash_pos != std::string::npos && space_pos != std::string::npos) {
                std::string field_name = field_match.substr(slash_pos, space_pos - slash_pos);
                std::string key_name = field_name.substr(1); // Remove leading '/'
                
                // Check for authentic source value
                auto source_it = source_metadata_.find(key_name);
                if (source_it != source_metadata_.end() && !source_it->second.empty() &&
                    source_it->second != "unknown" && source_it->second != "blank") {
                    // Use authentic source value
                    std::string replacement = field_name + " (" + source_it->second + ")";
                    data_str = std::regex_replace(data_str, std::regex(std::regex_replace(field_match, std::regex(R"([\[\]\(\)\*\+\?\.\^$|\\])"), R"(\$&)")), replacement);
                } else {
                    // Keep field but make blank
                    std::string replacement = field_name + " ()";
                    data_str = std::regex_replace(data_str, std::regex(std::regex_replace(field_match, std::regex(R"([\[\]\(\)\*\+\?\.\^$|\\])"), R"(\$&)")), replacement);
                }
            }
        }
    }
    
    // Remove any unwrapping text within parentheses but keep field structure
    std::regex unwrap_cleaners[] = {
        std::regex(R"(\([^)]*(?:unknown|blank|empty|default|none|null|undefined|N/A|unset|missing|auto|generated)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(\([^)]*(?:Created|Generated|Produced|Made|Built|Converted|Processed|Rendered|Exported)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(\([^)]*version\s+[0-9]+\.[0-9]+[^)]*\))", std::regex_constants::icase)
    };
    
    for (const auto& pattern : unwrap_cleaners) {
        data_str = std::regex_replace(data_str, pattern, "()");
    }
    
    result.assign(data_str.begin(), data_str.end());
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_compression_artifacts(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    // Remove compression-related metadata that might indicate processing tools
    result = AntiFingerprintUtils::remove_pattern(result, "/DecodeParms");
    result = AntiFingerprintUtils::remove_pattern(result, "/Predictor");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::sanitize_object_references(const std::vector<uint8_t>& data) {
    // Remove object references that might indicate tool processing
    std::vector<uint8_t> result = data;
    std::string data_str(result.begin(), result.end());
    
    // Remove comments that might contain tool information
    std::regex comment_pattern(R"(%[^\r\n]*)");
    data_str = std::regex_replace(data_str, comment_pattern, "");
    
    result.assign(data_str.begin(), data_str.end());
    return result;
}

// STRICT SOURCE-ONLY POLICY Implementation
void AntiFingerprintEngine::set_source_metadata(const std::string& key, const std::string& value) {
    std::lock_guard<std::mutex> lock(fingerprint_mutex_);
    source_metadata_[key] = value;
    
    // Set specific fields for quick access
    if (key == "Producer") {
        source_producer_ = value;
    } else if (key == "Creator") {
        source_creator_ = value;
    } else if (key == "ModDate") {
        source_modification_date_ = value;
    } else if (key == "CreationDate") {
        source_creation_date_ = value;
    }
}

void AntiFingerprintEngine::clear_source_metadata() {
    std::lock_guard<std::mutex> lock(fingerprint_mutex_);
    source_metadata_.clear();
    source_producer_.clear();
    source_creator_.clear();
    source_modification_date_.clear();
    source_creation_date_.clear();
}

std::vector<uint8_t> AntiFingerprintEngine::process(const std::vector<uint8_t>& data) {
    std::lock_guard<std::mutex> lock(fingerprint_mutex_);
    
    // CRITICAL: Remove ALL processing timestamps and tool traces
    std::vector<uint8_t> result = data;
    
    // Step 1: FIRST remove any current processing timestamps (highest priority)
    result = remove_all_processing_timestamps(result);
    
    // Step 2: Remove all library watermarks and signatures
    result = remove_library_watermarks(result);
    
    // Step 3: Replace defaults only with source values (blank otherwise)
    result = replace_default_values(result);
    
    // Step 4: Neutralize timestamps (blank if no source)
    result = neutralize_timestamps(result);
    
    // Step 5: Remove all tool signatures
    result = remove_tool_signatures(result);
    
    // Step 6: Clean metadata traces (blank if no source)
    result = clean_metadata_traces(result);
    
    // Step 7: Remove compression artifacts
    result = remove_compression_artifacts(result);
    
    // Step 8: Sanitize object references
    result = sanitize_object_references(result);
    
    // Step 9: Final enforcement of blank fields policy
    enforce_blank_fields_policy(result);
    
    // Step 10: FINAL scan to remove any remaining processing artifacts
    result = final_processing_timestamp_removal(result);
    
    // Step 11: CRITICAL - Synchronize XMP and DocInfo metadata (prevent tampering detection)
    result = synchronize_xmp_docinfo(result);
    
    return result;
}

void AntiFingerprintEngine::enforce_blank_fields_policy(std::vector<uint8_t>& data) {
    std::string data_str(data.begin(), data.end());
    
    // STRICT POLICY: Keep field structure intact, prevent unwrapping - NO field deletion
    
    // Replace any DEFAULT/FALLBACK text with empty parentheses (preserve field structure)
    std::regex default_text_patterns[] = {
        std::regex(R"(\(unknown\))", std::regex_constants::icase),
        std::regex(R"(\(blank\))", std::regex_constants::icase),
        std::regex(R"(\(empty\))", std::regex_constants::icase),
        std::regex(R"(\(default\))", std::regex_constants::icase),
        std::regex(R"(\(none\))", std::regex_constants::icase),
        std::regex(R"(\(null\))", std::regex_constants::icase),
        std::regex(R"(\(undefined\))", std::regex_constants::icase),
        std::regex(R"(\(not specified\))", std::regex_constants::icase),
        std::regex(R"(\(not available\))", std::regex_constants::icase),
        std::regex(R"(\(N/A\))", std::regex_constants::icase),
        std::regex(R"(\(unset\))", std::regex_constants::icase),
        std::regex(R"(\(missing\))", std::regex_constants::icase)
    };
    
    for (const auto& pattern : default_text_patterns) {
        data_str = std::regex_replace(data_str, pattern, "()");
    }
    
    // Clean metadata fields that got default values - keep field, blank value
    std::regex auto_defaults[] = {
        std::regex(R"(/Producer\s*\([^)]*(?:unknown|default|generated|automatic)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(/Creator\s*\([^)]*(?:unknown|default|generated|automatic)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(/Title\s*\([^)]*(?:unknown|default|untitled|document)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(/Author\s*\([^)]*(?:unknown|default|anonymous|user)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(/Subject\s*\([^)]*(?:unknown|default|no subject)[^)]*\))", std::regex_constants::icase)
    };
    
    for (size_t i = 0; i < sizeof(auto_defaults)/sizeof(auto_defaults[0]); ++i) {
        const auto& pattern = auto_defaults[i];
        
        std::sregex_iterator iter(data_str.begin(), data_str.end(), pattern);
        std::sregex_iterator end;
        
        for (; iter != end; ++iter) {
            const std::smatch& match = *iter;
            std::string field_match = match.str();
            
            // Extract field name and replace with blank value
            size_t slash_pos = field_match.find('/');
            size_t space_pos = field_match.find(' ', slash_pos);
            if (slash_pos != std::string::npos && space_pos != std::string::npos) {
                std::string field_name = field_match.substr(slash_pos, space_pos - slash_pos);
                std::string replacement = field_name + " ()";
                data_str = std::regex_replace(data_str, std::regex(std::regex_replace(field_match, std::regex(R"([\[\]\(\)\*\+\?\.\^$|\\])"), R"(\$&)")), replacement);
            }
        }
    }
    
    // Clean timestamp fields that got auto-generated values - keep field, blank value
    std::regex auto_timestamps[] = {
        std::regex(R"(/ModDate\s*\(D:[0-9]{14}[+-][0-9]{2}'[0-9]{2}'\))", std::regex_constants::icase),
        std::regex(R"(/CreationDate\s*\(D:[0-9]{14}[+-][0-9]{2}'[0-9]{2}'\))", std::regex_constants::icase),
        std::regex(R"(/ModDate\s*\([^)]*(?:now|current|today|auto)[^)]*\))", std::regex_constants::icase),
        std::regex(R"(/CreationDate\s*\([^)]*(?:now|current|today|auto)[^)]*\))", std::regex_constants::icase)
    };
    
    for (const auto& pattern : auto_timestamps) {
        // Only clean if no authentic source data is available
        if ((data_str.find("/ModDate") != std::string::npos && source_modification_date_.empty()) ||
            (data_str.find("/CreationDate") != std::string::npos && source_creation_date_.empty())) {
            
            std::sregex_iterator iter(data_str.begin(), data_str.end(), pattern);
            std::sregex_iterator end;
            
            for (; iter != end; ++iter) {
                const std::smatch& match = *iter;
                std::string field_match = match.str();
                
                // Extract field name and replace with blank value
                size_t slash_pos = field_match.find('/');
                size_t space_pos = field_match.find(' ', slash_pos);
                if (slash_pos != std::string::npos && space_pos != std::string::npos) {
                    std::string field_name = field_match.substr(slash_pos, space_pos - slash_pos);
                    std::string replacement = field_name + " ()";
                    data_str = std::regex_replace(data_str, std::regex(std::regex_replace(field_match, std::regex(R"([\[\]\(\)\*\+\?\.\^$|\\])"), R"(\$&)")), replacement);
                }
            }
        }
    }
    
    // Clean up whitespace but preserve PDF structure
    std::regex cleanup_patterns[] = {
        std::regex(R"(\s{3,})"),  // Excessive spaces (3 or more)
        std::regex(R"(\n{3,})")   // Excessive newlines (3 or more)
    };
    
    for (const auto& pattern : cleanup_patterns) {
        if (pattern == cleanup_patterns[0]) {
            data_str = std::regex_replace(data_str, pattern, "  "); // Keep some spacing
        } else {
            data_str = std::regex_replace(data_str, pattern, "\n\n"); // Keep some structure
        }
    }
    
    data.assign(data_str.begin(), data_str.end());
}

// CRITICAL: Remove ALL processing timestamps from current tool execution
std::vector<uint8_t> AntiFingerprintEngine::remove_all_processing_timestamps(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    std::string data_str(result.begin(), result.end());
    
    // Remove ANY timestamps that could indicate when this tool was run
    std::regex current_time_patterns[] = {
        // Current date patterns (2024-2025 indicate recent processing)
        std::regex(R"(D:202[4-9][0-9]{10}[+-][0-9]{2}'[0-9]{2}')", std::regex_constants::icase),
        std::regex(R"(202[4-9]-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2})", std::regex_constants::icase),
        std::regex(R"(202[4-9]/[0-9]{2}/[0-9]{2}\s+[0-9]{2}:[0-9]{2}:[0-9]{2})", std::regex_constants::icase),
        
        // Processing indicators with timestamps
        std::regex(R"(Processing\s+(?:date|time):\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(Generated\s+(?:on|at):\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(Modified\s+(?:on|at):\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(Created\s+(?:on|at):\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(Build\s+(?:date|time):\s*[^\n]+)", std::regex_constants::icase),
        
        // Auto-generated timestamp indicators
        std::regex(R"(\(auto-generated[^)]*\))", std::regex_constants::icase),
        std::regex(R"(\(current[^)]*\))", std::regex_constants::icase),
        std::regex(R"(\(now[^)]*\))", std::regex_constants::icase),
        std::regex(R"(\(today[^)]*\))", std::regex_constants::icase)
    };
    
    for (const auto& pattern : current_time_patterns) {
        data_str = std::regex_replace(data_str, pattern, "");
    }
    
    result.assign(data_str.begin(), data_str.end());
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::final_processing_timestamp_removal(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    std::string data_str(result.begin(), result.end());
    
    // FINAL scan: Ensure NO processing timestamps leaked through
    
    // Force ModDate to blank if it contains recent timestamps (tool processing indicators)
    std::regex recent_moddate_pattern(R"(/ModDate\s*\(D:202[4-9][0-9]{10}[^)]*\))");
    data_str = std::regex_replace(data_str, recent_moddate_pattern, "/ModDate ()");
    
    // Force CreationDate to blank if it contains recent timestamps  
    std::regex recent_creationdate_pattern(R"(/CreationDate\s*\(D:202[4-9][0-9]{10}[^)]*\))");
    data_str = std::regex_replace(data_str, recent_creationdate_pattern, "/CreationDate ()");
    
    // Remove any remaining tool execution timestamps anywhere in the document
    std::regex execution_artifacts[] = {
        std::regex(R"(Processed\s+at:\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(Execution\s+time:\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(Runtime:\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(Tool\s+run\s+at:\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(System\s+time:\s*[^\n]+)", std::regex_constants::icase),
        std::regex(R"(UTC\s+time:\s*[^\n]+)", std::regex_constants::icase)
    };
    
    for (const auto& pattern : execution_artifacts) {
        data_str = std::regex_replace(data_str, pattern, "");
    }
    
    // Remove any metadata that might contain processing timestamps
    std::regex metadata_with_processing_time[] = {
        std::regex(R"(/ProcessedAt\s*\([^)]*\))", std::regex_constants::icase),
        std::regex(R"(/ToolExecutionTime\s*\([^)]*\))", std::regex_constants::icase),
        std::regex(R"(/LastProcessed\s*\([^)]*\))", std::regex_constants::icase),
        std::regex(R"(/SystemTime\s*\([^)]*\))", std::regex_constants::icase)
    };
    
    for (const auto& pattern : metadata_with_processing_time) {
        // Extract field name and make blank
        std::sregex_iterator iter(data_str.begin(), data_str.end(), pattern);
        std::sregex_iterator end;
        
        for (; iter != end; ++iter) {
            const std::smatch& match = *iter;
            std::string field_match = match.str();
            
            size_t slash_pos = field_match.find('/');
            size_t space_pos = field_match.find(' ', slash_pos);
            if (slash_pos != std::string::npos && space_pos != std::string::npos) {
                std::string field_name = field_match.substr(slash_pos, space_pos - slash_pos);
                std::string replacement = field_name + " ()";
                data_str = std::regex_replace(data_str, std::regex(std::regex_replace(field_match, std::regex(R"([\[\]\(\)\*\+\?\.\^$|\\])"), R"(\$&)")), replacement);
            }
        }
    }
    
    result.assign(data_str.begin(), data_str.end());
    return result;
}

// CRITICAL: XMP-DocInfo synchronization to prevent tampering detection
std::vector<uint8_t> AntiFingerprintEngine::synchronize_xmp_docinfo(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    std::string data_str(result.begin(), result.end());
    
    // Extract DocInfo metadata values
    std::map<std::string, std::string> docinfo_values;
    
    // Extract current DocInfo values
    std::regex docinfo_patterns[] = {
        std::regex(R"(/Title\s*\(([^)]*)\))"),
        std::regex(R"(/Author\s*\(([^)]*)\))"),
        std::regex(R"(/Subject\s*\(([^)]*)\))"),
        std::regex(R"(/Keywords\s*\(([^)]*)\))"),
        std::regex(R"(/Creator\s*\(([^)]*)\))"),
        std::regex(R"(/Producer\s*\(([^)]*)\))"),
        std::regex(R"(/CreationDate\s*\(([^)]*)\))"),
        std::regex(R"(/ModDate\s*\(([^)]*)\))")
    };
    
    std::string field_names[] = {
        "Title", "Author", "Subject", "Keywords", 
        "Creator", "Producer", "CreationDate", "ModDate"
    };
    
    for (size_t i = 0; i < sizeof(docinfo_patterns)/sizeof(docinfo_patterns[0]); ++i) {
        std::smatch match;
        if (std::regex_search(data_str, match, docinfo_patterns[i])) {
            docinfo_values[field_names[i]] = match[1].str();
        }
    }
    
    // Find XMP metadata section
    size_t xmp_start = data_str.find("<x:xmpmeta");
    if (xmp_start == std::string::npos) {
        xmp_start = data_str.find("<?xpacket");
    }
    
    if (xmp_start != std::string::npos) {
        size_t xmp_end = data_str.find("</x:xmpmeta>", xmp_start);
        if (xmp_end == std::string::npos) {
            xmp_end = data_str.find("<?xpacket end=", xmp_start);
        }
        
        if (xmp_end != std::string::npos) {
            // Extract XMP section
            std::string xmp_section = data_str.substr(xmp_start, xmp_end - xmp_start + 20);
            
            // Synchronize XMP with DocInfo values
            std::string synchronized_xmp = xmp_section;
            
            // Update XMP fields to match DocInfo
            std::regex xmp_patterns[] = {
                std::regex(R"(<dc:title>\s*<rdf:Alt>\s*<rdf:li[^>]*>([^<]*)</rdf:li>\s*</rdf:Alt>\s*</dc:title>)"),
                std::regex(R"(<dc:creator>\s*<rdf:Seq>\s*<rdf:li>([^<]*)</rdf:li>\s*</rdf:Seq>\s*</dc:creator>)"),
                std::regex(R"(<dc:description>\s*<rdf:Alt>\s*<rdf:li[^>]*>([^<]*)</rdf:li>\s*</rdf:Alt>\s*</dc:description>)"),
                std::regex(R"(<pdf:Keywords>([^<]*)</pdf:Keywords>)"),
                std::regex(R"(<xmp:CreatorTool>([^<]*)</xmp:CreatorTool>)"),
                std::regex(R"(<pdf:Producer>([^<]*)</pdf:Producer>)"),
                std::regex(R"(<xmp:CreateDate>([^<]*)</xmp:CreateDate>)"),
                std::regex(R"(<xmp:ModifyDate>([^<]*)</xmp:ModifyDate>)")
            };
            
            std::string xmp_field_names[] = {
                "Title", "Author", "Subject", "Keywords",
                "Creator", "Producer", "CreationDate", "ModDate"
            };
            
            for (size_t i = 0; i < sizeof(xmp_patterns)/sizeof(xmp_patterns[0]); ++i) {
                const std::string& field_name = xmp_field_names[i];
                auto docinfo_it = docinfo_values.find(field_name);
                
                if (docinfo_it != docinfo_values.end()) {
                    std::string docinfo_value = docinfo_it->second;
                    
                    // Create synchronized XMP entry
                    std::string xmp_replacement;
                    if (i == 0) { // Title
                        if (docinfo_value.empty()) {
                            xmp_replacement = "<dc:title><rdf:Alt><rdf:li xml:lang=\"x-default\"></rdf:li></rdf:Alt></dc:title>";
                        } else {
                            xmp_replacement = "<dc:title><rdf:Alt><rdf:li xml:lang=\"x-default\">" + docinfo_value + "</rdf:li></rdf:Alt></dc:title>";
                        }
                    } else if (i == 1) { // Author
                        if (docinfo_value.empty()) {
                            xmp_replacement = "<dc:creator><rdf:Seq><rdf:li></rdf:li></rdf:Seq></dc:creator>";
                        } else {
                            xmp_replacement = "<dc:creator><rdf:Seq><rdf:li>" + docinfo_value + "</rdf:li></rdf:Seq></dc:creator>";
                        }
                    } else if (i == 2) { // Subject
                        if (docinfo_value.empty()) {
                            xmp_replacement = "<dc:description><rdf:Alt><rdf:li xml:lang=\"x-default\"></rdf:li></rdf:Alt></dc:description>";
                        } else {
                            xmp_replacement = "<dc:description><rdf:Alt><rdf:li xml:lang=\"x-default\">" + docinfo_value + "</rdf:li></rdf:Alt></dc:description>";
                        }
                    } else if (i == 3) { // Keywords
                        xmp_replacement = "<pdf:Keywords>" + docinfo_value + "</pdf:Keywords>";
                    } else if (i == 4) { // Creator
                        xmp_replacement = "<xmp:CreatorTool>" + docinfo_value + "</xmp:CreatorTool>";
                    } else if (i == 5) { // Producer
                        xmp_replacement = "<pdf:Producer>" + docinfo_value + "</pdf:Producer>";
                    } else if (i == 6) { // CreationDate
                        if (!docinfo_value.empty() && docinfo_value.find("D:") == 0) {
                            // Convert PDF date format to XMP format
                            std::string xmp_date = convert_pdf_date_to_xmp(docinfo_value);
                            xmp_replacement = "<xmp:CreateDate>" + xmp_date + "</xmp:CreateDate>";
                        } else {
                            xmp_replacement = "<xmp:CreateDate></xmp:CreateDate>";
                        }
                    } else if (i == 7) { // ModDate
                        if (!docinfo_value.empty() && docinfo_value.find("D:") == 0) {
                            // Convert PDF date format to XMP format
                            std::string xmp_date = convert_pdf_date_to_xmp(docinfo_value);
                            xmp_replacement = "<xmp:ModifyDate>" + xmp_date + "</xmp:ModifyDate>";
                        } else {
                            xmp_replacement = "<xmp:ModifyDate></xmp:ModifyDate>";
                        }
                    }
                    
                    // Replace XMP field with synchronized value
                    synchronized_xmp = std::regex_replace(synchronized_xmp, xmp_patterns[i], xmp_replacement);
                }
            }
            
            // Replace original XMP with synchronized XMP
            data_str.replace(xmp_start, xmp_end - xmp_start + 20, synchronized_xmp);
        }
    }
    
    result.assign(data_str.begin(), data_str.end());
    return result;
}

std::string AntiFingerprintEngine::convert_pdf_date_to_xmp(const std::string& pdf_date) {
    // Convert PDF date format (D:YYYYMMDDHHmmSSOHH'mm') to XMP format (YYYY-MM-DDTHH:mm:SS+HH:mm)
    if (pdf_date.length() < 16 || pdf_date.substr(0, 2) != "D:") {
        return "";
    }
    
    std::string date_part = pdf_date.substr(2);
    if (date_part.length() < 14) {
        return "";
    }
    
    std::string year = date_part.substr(0, 4);
    std::string month = date_part.substr(4, 2);
    std::string day = date_part.substr(6, 2);
    std::string hour = date_part.substr(8, 2);
    std::string minute = date_part.substr(10, 2);
    std::string second = date_part.substr(12, 2);
    
    std::string xmp_date = year + "-" + month + "-" + day + "T" + hour + ":" + minute + ":" + second;
    
    // Handle timezone if present
    if (date_part.length() > 14) {
        char tz_sign = date_part[14];
        if (tz_sign == '+' || tz_sign == '-') {
            if (date_part.length() >= 19) {
                std::string tz_hour = date_part.substr(15, 2);
                std::string tz_min = date_part.substr(18, 2);
                xmp_date += tz_sign + tz_hour + ":" + tz_min;
            }
        } else {
            xmp_date += "Z"; // UTC
        }
    } else {
        xmp_date += "Z"; // Default to UTC
    }
    
    return xmp_date;
}

// Library-specific removal methods
std::vector<uint8_t> AntiFingerprintEngine::remove_poppler_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "poppler");
    result = AntiFingerprintUtils::remove_pattern(result, "Poppler");
    result = AntiFingerprintUtils::remove_pattern(result, "cairo");
    result = AntiFingerprintUtils::remove_pattern(result, "Cairo");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_pdfium_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "PDFium");
    result = AntiFingerprintUtils::remove_pattern(result, "pdfium");
    result = AntiFingerprintUtils::remove_pattern(result, "Chromium");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_itext_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "iText");
    result = AntiFingerprintUtils::remove_pattern(result, "iTextSharp");
    result = AntiFingerprintUtils::remove_pattern(result, "itext");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_pdftk_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "pdftk");
    result = AntiFingerprintUtils::remove_pattern(result, "PDFtk");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_ghostscript_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "GPL Ghostscript");
    result = AntiFingerprintUtils::remove_pattern(result, "AFPL Ghostscript");
    result = AntiFingerprintUtils::remove_pattern(result, "Ghostscript");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_mupdf_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "MuPDF");
    result = AntiFingerprintUtils::remove_pattern(result, "mupdf");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_cairo_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "cairo");
    result = AntiFingerprintUtils::remove_pattern(result, "Cairo");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::remove_qpdf_traces(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    result = AntiFingerprintUtils::remove_pattern(result, "qpdf");
    result = AntiFingerprintUtils::remove_pattern(result, "QPDF");
    result = AntiFingerprintUtils::remove_pattern(result, "libqpdf");
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::replace_creation_metadata(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    if (!source_creator_.empty()) {
        std::string data_str(result.begin(), result.end());
        std::regex creator_pattern(R"(/Creator\s*\([^)]*\))");
        std::string replacement = "/Creator (" + source_creator_ + ")";
        data_str = std::regex_replace(data_str, creator_pattern, replacement);
        result.assign(data_str.begin(), data_str.end());
    }
    
    return result;
}

std::vector<uint8_t> AntiFingerprintEngine::clone_authentic_timestamps(const std::vector<uint8_t>& data) {
    return neutralize_timestamps(data); // Same implementation
}

std::vector<uint8_t> AntiFingerprintEngine::replace_producer_info(const std::vector<uint8_t>& data) {
    std::vector<uint8_t> result = data;
    
    if (!source_producer_.empty()) {
        std::string data_str(result.begin(), result.end());
        std::regex producer_pattern(R"(/Producer\s*\([^)]*\))");
        std::string replacement = "/Producer (" + source_producer_ + ")";
        data_str = std::regex_replace(data_str, producer_pattern, replacement);
        result.assign(data_str.begin(), data_str.end());
    }
    
    return result;
}

bool AntiFingerprintEngine::verify_trace_free(const std::vector<uint8_t>& pdf_data) {
    auto traces = detect_processing_traces(pdf_data);
    return traces.empty();
}

std::vector<AntiFingerprintEngine::ProcessingTrace> AntiFingerprintEngine::detect_processing_traces(const std::vector<uint8_t>& pdf_data) {
    std::vector<ProcessingTrace> traces;
    std::string data_str(pdf_data.begin(), pdf_data.end());
    
    // Check for known library signatures
    for (const auto& signature : known_signatures_) {
        for (const auto& pattern : signature.signature_patterns) {
            if (data_str.find(pattern) != std::string::npos) {
                ProcessingTrace trace;
                trace.trace_type = "Library Signature";
                trace.location = signature.library_name + ": " + pattern;
                trace.is_critical = true;
                traces.push_back(trace);
            }
        }
    }
    
    return traces;
}

// Utility function implementations
namespace AntiFingerprintUtils {
    std::vector<uint8_t> replace_pattern(const std::vector<uint8_t>& data, 
                                        const std::string& pattern, 
                                        const std::string& replacement) {
        std::string data_str(data.begin(), data.end());
        
        size_t pos = 0;
        while ((pos = data_str.find(pattern, pos)) != std::string::npos) {
            data_str.replace(pos, pattern.length(), replacement);
            pos += replacement.length();
        }
        
        return std::vector<uint8_t>(data_str.begin(), data_str.end());
    }
    
    std::vector<uint8_t> remove_pattern(const std::vector<uint8_t>& data, 
                                       const std::string& pattern) {
        return replace_pattern(data, pattern, "");
    }
    
    std::map<std::string, std::string> extract_authentic_metadata(const std::vector<uint8_t>& source_pdf) {
        std::map<std::string, std::string> metadata;
        std::string pdf_str(source_pdf.begin(), source_pdf.end());
        
        // Extract CreationDate
        std::regex creation_pattern(R"(/CreationDate\s*\(([^)]+)\))");
        std::smatch match;
        if (std::regex_search(pdf_str, match, creation_pattern)) {
            metadata["CreationDate"] = match[1].str();
        }
        
        // Extract ModDate
        std::regex mod_pattern(R"(/ModDate\s*\(([^)]+)\))");
        if (std::regex_search(pdf_str, match, mod_pattern)) {
            metadata["ModDate"] = match[1].str();
        }
        
        // Extract Producer
        std::regex producer_pattern(R"(/Producer\s*\(([^)]+)\))");
        if (std::regex_search(pdf_str, match, producer_pattern)) {
            metadata["Producer"] = match[1].str();
        }
        
        // Extract Creator
        std::regex creator_pattern(R"(/Creator\s*\(([^)]+)\))");
        if (std::regex_search(pdf_str, match, creator_pattern)) {
            metadata["Creator"] = match[1].str();
        }
        
        return metadata;
    }
}